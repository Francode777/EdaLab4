import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Comparator;


public class AreaAttention {

    private String name;
    private PriorityQueue<Patient> patientHeap;//mantiene los paciente ordenados por orden de llegada y urgencia --> atento con esto
    private int maxCapacity;

    // usaré compare, entonces tengo que crear otra clase artificial

    //-1 es p1 va antes que p2
    //1 es p2 va antes que p1
    //en caso de ser iguales seria 0, pero vamos a resolverlo con su orden de llegada, o sea, viendo que quien lleva mas tiempo esperando

    Comparator<Patient> c = new Comparator<Patient>() {//evaluar los peores caso para el informe
        public int compare(Patient p1, Patient p2) {
            if (p1.getCategoria() < p2.getCategoria()) {
                return -1;
            }
            if (p1.getCategoria() > p2.getCategoria()) {
                return 1;
            } else {//tienen la misma categoria, se resuelve en base a su orden de llegada
                if (p1.getArrivalTime() < p2.getArrivalTime()) {//pendiente-> posible solucion crear un metodo que compare la horas
                    return -1;
                }
                if (p1.getArrivalTime() > p2.getArrivalTime()) {//pendiente
                    return 1;
                } else {
                    return 0;
                }
            }
        }
    };


   /*
este es un ejemplo de como se veria el heap, podemos ver que el Fran es el que esta con mas urgencia con C1 y un tiempo de llegada
anterior a los demas a pesar de que Guliano por ejemplo tenga su misma categoria de urgencia. Por ende al hacer el poll() mandará la cabeza,
que es Fran con C1 y su tiempo de llegada inferior al de Guliano.


              Fran (C1, 900)
            /               \
   Guliano (C1, 950)     Javiera (C3, 1000)
                          /
              Nasheee (C4, 1010)

    */

    public AreaAttention(String name, int maxCapacity) {// la cola para las pruebas se lo podemos dar de antemano ahi veremos
        this.name = name;
        this.maxCapacity = maxCapacity;
        patientHeap = new PriorityQueue<Patient>(c);
    }

    public void addPatient(Patient paciente) {
        if (thisSaturade()) {
            System.out.println("Se alcanzó la capacidad maxima en el área" + name);
        }else{//usaré offer en vez de add para que devuelva false en caso de que no se agregue en vez de que el code se rompa por un error
            patientHeap.offer(paciente);
        }
    }
    public Patient attendPatient() {
        Patient p = patientHeap.peek();
        p.setState("Atendido");
        return patientHeap.poll();
    }
    public boolean thisSaturade() {
        return patientHeap.size() >= maxCapacity;
    }
    public List<Patient> obtenerPacientesPorHeapSort() {
        PriorityQueue<Patient> aux = new PriorityQueue<Patient>(patientHeap); //creamos un auxiliar para no modificar el original

        List<Patient> ordenados = new ArrayList<Patient>();

        while (!aux.isEmpty()) {
            ordenados.add(aux.poll()); //ahora al ser una lista se usa add, offer solo usamos en colas
        }

        return ordenados;
    }

}


// obs mia, no tomar en cuenta:quiero revisar el heap y el compare


